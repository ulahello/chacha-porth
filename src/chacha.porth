// TODO: consistent ordering of args

/// std.porth copypaste //////////////
inline proc _ptr+ ptr int -- ptr in
  swap cast(int)
  swap cast(int)
  +
  cast(ptr)
end
const _sizeof(int) 8 end
const _sizeof(ptr) _sizeof(int) end
inline proc _!ptr ptr ptr in !64 end
inline proc _@ptr ptr -- ptr in @64 cast(ptr) end
inline proc _inc64 ptr in dup @64 1 + swap !64 end
proc _memcpy
  int // size
  ptr // src
  ptr // dst
  --
  ptr // dst
in
  memory src _sizeof(ptr) end
  memory dst _sizeof(ptr) end
  memory result _sizeof(ptr) end
  dst !64
  src !64
  dst _@ptr swap // result
  while dup 0 > do
    src _@ptr @8
    dst _@ptr !8
    src _inc64
    dst _inc64
    1 -
  end drop
end
/// end std.porth copypaste //////////////

const sizeof(word) 4 end

const CHACHA_CONST[0] 1634760805 end // b"expa"
const CHACHA_CONST[1] 857760878  end // b"nd-3"
const CHACHA_CONST[2] 2036477234 end // b"2 by"
const CHACHA_CONST[3] 1797285236 end // b"te k"

inline proc xor
  int // x
  int // y
  --
  int // x ^ y
in
  // (x | y) & (!(x & y))
  over over or
  rot rot
  and not
  and
end

// see <https://en.wikipedia.org/wiki/Circular_shift#Implementing_circular_shifts>
inline proc rotl32
  int // value
  int // count
  --
  int // value <<< count
in
  // value << count | value >> (32 - count)
  over over
  32 swap - shr
  rot rot
  shl
  or
end

const sizeof(State.const)   sizeof(word) 4 * end
const sizeof(State.key)     sizeof(word) 8 * end
const sizeof(State.counter) sizeof(word) 1 * end
const sizeof(State.nonce)   sizeof(word) 3 * end

const offsetof(State.const)   sizeof(State.const)   offset end
const offsetof(State.key)     sizeof(State.key)     offset end
const offsetof(State.counter) sizeof(State.counter) offset end
const offsetof(State.nonce)   sizeof(State.nonce)   offset end
const sizeof(State)                                  reset end

inline proc State.const    ptr -- ptr in offsetof(State.const)   _ptr+ end
inline proc State.key      ptr -- ptr in offsetof(State.key)     _ptr+ end
inline proc State.counter  ptr -- ptr in offsetof(State.counter) _ptr+ end
inline proc State.nonce    ptr -- ptr in offsetof(State.nonce)   _ptr+ end

inline proc @State.const
  ptr // &State
  --
  int int int int // words (0..4)
in
  State.const
  dup sizeof(word) 0 * _ptr+ @32 swap
  dup sizeof(word) 1 * _ptr+ @32 swap
  dup sizeof(word) 2 * _ptr+ @32 swap
      sizeof(word) 3 * _ptr+ @32
end

inline proc @State.key
  ptr // &State
  --
  int int int int int int int int // words (4..11)
in
  State.key
  dup sizeof(word) 0 * _ptr+ @32 swap
  dup sizeof(word) 1 * _ptr+ @32 swap
  dup sizeof(word) 2 * _ptr+ @32 swap
  dup sizeof(word) 3 * _ptr+ @32 swap
  dup sizeof(word) 4 * _ptr+ @32 swap
  dup sizeof(word) 5 * _ptr+ @32 swap
  dup sizeof(word) 6 * _ptr+ @32 swap
      sizeof(word) 7 * _ptr+ @32
end

inline proc @State.counter
  ptr // &State
  --
  int // word at index 11
in
  State.counter @32
end

inline proc @State.nonce
  ptr // &State
  --
  int int int // words (13..16)
in
  State.nonce
  dup sizeof(word) 0 * _ptr+ @32 swap
  dup sizeof(word) 1 * _ptr+ @32 swap
      sizeof(word) 2 * _ptr+ @32
end

inline proc !State.const
  int int int int // words (0..4)
  ptr // &mut State
in
  State.const
  dup sizeof(word) 3 * _ptr+ rot swap !32
  dup sizeof(word) 2 * _ptr+ rot swap !32
  dup sizeof(word) 1 * _ptr+ rot swap !32
  dup sizeof(word) 0 * _ptr+ rot swap !32
  drop
end

inline proc !State.key
  int int int int int int int int // words (4..11)
  ptr // &mut State
in
  State.key
  dup sizeof(word) 7 * _ptr+ rot swap !32
  dup sizeof(word) 6 * _ptr+ rot swap !32
  dup sizeof(word) 5 * _ptr+ rot swap !32
  dup sizeof(word) 4 * _ptr+ rot swap !32
  dup sizeof(word) 3 * _ptr+ rot swap !32
  dup sizeof(word) 2 * _ptr+ rot swap !32
  dup sizeof(word) 1 * _ptr+ rot swap !32
  dup sizeof(word) 0 * _ptr+ rot swap !32
  drop
end

inline proc !State.counter
  int // word at index 11
  ptr // &mut State
in
  State.counter !32
end

inline proc !State.nonce
  int int int // words (13..16)
  ptr // &mut State
in
  State.nonce
  dup sizeof(word) 2 * _ptr+ rot swap !32
  dup sizeof(word) 1 * _ptr+ rot swap !32
  dup sizeof(word) 0 * _ptr+ rot swap !32
  drop
end

proc @State
  ptr // &State
  --
  int int int int int int int int int int int int int int int int // words (0..16)
in
  memory start _sizeof(ptr) end start _!ptr
  start _@ptr @State.const
  start _@ptr @State.key
  start _@ptr @State.counter
  start _@ptr @State.nonce
end

proc !State
  int int int int int int int int int int int int int int int int // words (0..16)
  ptr // &mut State
in
  memory loc _sizeof(ptr) end loc _!ptr
  loc _@ptr !State.nonce
  loc _@ptr !State.counter
  loc _@ptr !State.key
  loc _@ptr !State.const
end

proc qr
  int int int int // words (d, c, b, a)
  --
  int int int int // words (d, c, b, a)
in
  memory a sizeof(word) end a !32
  memory b sizeof(word) end b !32
  memory c sizeof(word) end c !32
  memory d sizeof(word) end d !32

  a @32 b @32 +      a !32 // a += b
  d @32 a @32 xor    d !32 // d ^= a
  d @32 16    rotl32 d !32 // d <<<= 16

  c @32 d @32 +      c !32 // c += d
  b @32 c @32 xor    b !32 // b ^= c
  b @32 12    rotl32 b !32 // b <<<= 12

  a @32 b @32 +      a !32 // a += b
  d @32 a @32 xor    d !32 // d ^= a
  d @32 8     rotl32 d !32 // d <<<= 8

  c @32 d @32 +      c !32 // c += d
  b @32 c @32 xor    b !32 // b ^= c
  b @32 7     rotl32 b !32 // b <<<= 7

  d @32
  c @32
  b @32
  a @32
end

proc qr_index
  int int int int // indexes (a, b, c, d)
  ptr // &mut State
in
  memory state _sizeof(ptr) end state _!ptr
  memory d _sizeof(int) end d !64
  memory c _sizeof(int) end c !64
  memory b _sizeof(int) end b !64
  memory a _sizeof(int) end a !64

  state   _@ptr sizeof(word) d @64 * _ptr+ @32
    state _@ptr sizeof(word) c @64 * _ptr+ @32
    state _@ptr sizeof(word) b @64 * _ptr+ @32
    state _@ptr sizeof(word) a @64 * _ptr+ @32

    qr

    state _@ptr sizeof(word) a @64 * _ptr+ !32
    state _@ptr sizeof(word) b @64 * _ptr+ !32
    state _@ptr sizeof(word) c @64 * _ptr+ !32
  state   _@ptr sizeof(word) d @64 * _ptr+ !32
end

proc round_odd
  ptr // &mut State
in
  memory state _sizeof(ptr) end state _!ptr
  0 4  8 12 state _@ptr qr_index // column 1
  1 5  9 13 state _@ptr qr_index // column 2
  2 6 10 14 state _@ptr qr_index // column 3
  3 7 11 15 state _@ptr qr_index // column 4
end

proc round_even
  ptr // &mut State
in
  memory state _sizeof(ptr) end state _!ptr
  0 5 10 15 state _@ptr qr_index // diagonal 1
  1 6 11 12 state _@ptr qr_index // diagonal 2
  2 7  8 13 state _@ptr qr_index // diagonal 3
  3 4  9 14 state _@ptr qr_index // diagonal 4
end

// TODO: if this is inlined, program segfaults (compiler bug?)
proc block_no_add
  ptr // &mut State
  int // num_rounds
in
  1 while over over >= do
    dup 1 and 0 = if // if current round is even
      rot dup round_even
      rot rot
    else
      rot dup round_odd
      rot rot
    end
    1 +
  end drop
  drop drop
end

// s1 += s2
proc state+
  ptr // s1: &mut State
  ptr // s2: &State
in
  memory s2 _sizeof(ptr) end s2 _!ptr
  memory s1 _sizeof(ptr) end s1 _!ptr
  0 while dup sizeof(State) < do
    s1 _@ptr over _ptr+ @32      // push s1[i]
    over s2 _@ptr swap _ptr+ @32 // push s2[i]
    +
    over s1 _@ptr swap _ptr+ !32 // s1[i] = s1[i] + s2[i]

    sizeof(word) +
  end drop
end

proc block
  ptr // &mut State
  int // num_rounds
in
  // make copy of original state
  memory original sizeof(State) end
  over sizeof(State) swap original _memcpy drop

  // compute rounds
  over over block_no_add

  // add original to current state
  drop original state+
end
