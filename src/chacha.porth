// NOTE: depends on "std.porth"

// TODO: consistent ordering of args

const sizeof(word) sizeof(u32)      end
const bits(word)   sizeof(word) 8 * end

const CHACHA_CONST[0] 1634760805 end // b"expa"
const CHACHA_CONST[1] 857760878  end // b"nd-3"
const CHACHA_CONST[2] 2036477234 end // b"2 by"
const CHACHA_CONST[3] 1797285236 end // b"te k"

inline proc ^ int int -- int in
  // (a | b) & (!(a & b))
  over over or
  rot rot
  and not
  and
end

// see <https://en.wikipedia.org/wiki/Circular_shift#Implementing_circular_shifts>
inline proc <<<
  int // value
  int // n bits left
  --
  int
in
  // value << count | value >> (32 - count)
  over over
  bits(word) swap - shr
  rot rot
  shl
  or
end

const sizeof(State.const)   sizeof(word) 4 * end
const sizeof(State.key)     sizeof(word) 8 * end
const sizeof(State.counter) sizeof(word) 1 * end
const sizeof(State.nonce)   sizeof(word) 3 * end

const offsetof(State.const)   sizeof(State.const)   offset end
const offsetof(State.key)     sizeof(State.key)     offset end
const offsetof(State.counter) sizeof(State.counter) offset end
const offsetof(State.nonce)   sizeof(State.nonce)   offset end
const sizeof(State)                                  reset end

inline proc State.const    ptr -- ptr in offsetof(State.const)   ptr+ end
inline proc State.key      ptr -- ptr in offsetof(State.key)     ptr+ end
inline proc State.counter  ptr -- ptr in offsetof(State.counter) ptr+ end
inline proc State.nonce    ptr -- ptr in offsetof(State.nonce)   ptr+ end

inline proc @State.const
  ptr
  --
  int int int int
in
  State.const
  dup sizeof(word) 0 * ptr+ @32 swap
  dup sizeof(word) 1 * ptr+ @32 swap
  dup sizeof(word) 2 * ptr+ @32 swap
      sizeof(word) 3 * ptr+ @32
end

inline proc @State.key
  ptr
  --
  int int int int int int int int
in
  State.key
  dup sizeof(word) 0 * ptr+ @32 swap
  dup sizeof(word) 1 * ptr+ @32 swap
  dup sizeof(word) 2 * ptr+ @32 swap
  dup sizeof(word) 3 * ptr+ @32 swap
  dup sizeof(word) 4 * ptr+ @32 swap
  dup sizeof(word) 5 * ptr+ @32 swap
  dup sizeof(word) 6 * ptr+ @32 swap
      sizeof(word) 7 * ptr+ @32
end

inline proc @State.counter ptr -- int in State.counter @32 end

inline proc @State.nonce
  ptr
  --
  int int int
in
  State.nonce
  dup sizeof(word) 0 * ptr+ @32 swap
  dup sizeof(word) 1 * ptr+ @32 swap
      sizeof(word) 2 * ptr+ @32
end

inline proc !State.const
  int int int int ptr
in
  State.const
  dup sizeof(word) 3 * ptr+ rot swap !32
  dup sizeof(word) 2 * ptr+ rot swap !32
  dup sizeof(word) 1 * ptr+ rot swap !32
  dup sizeof(word) 0 * ptr+ rot swap !32
  drop
end

inline proc !State.key
  int int int int int int int int ptr
in
  State.key
  dup sizeof(word) 7 * ptr+ rot swap !32
  dup sizeof(word) 6 * ptr+ rot swap !32
  dup sizeof(word) 5 * ptr+ rot swap !32
  dup sizeof(word) 4 * ptr+ rot swap !32
  dup sizeof(word) 3 * ptr+ rot swap !32
  dup sizeof(word) 2 * ptr+ rot swap !32
  dup sizeof(word) 1 * ptr+ rot swap !32
  dup sizeof(word) 0 * ptr+ rot swap !32
  drop
end

inline proc !State.counter int ptr in State.counter !32 end

inline proc !State.nonce
  int int int ptr
in
  State.nonce
  dup sizeof(word) 2 * ptr+ rot swap !32
  dup sizeof(word) 1 * ptr+ rot swap !32
  dup sizeof(word) 0 * ptr+ rot swap !32
  drop
end

proc @State
  ptr
  --
  int int int int int int int int int int int int int int int int
in
  memory start sizeof(ptr) end start !ptr
  start @ptr @State.const
  start @ptr @State.key
  start @ptr @State.counter
  start @ptr @State.nonce
end

proc !State
  int int int int int int int int int int int int int int int int ptr
in
  memory loc sizeof(ptr) end loc !ptr
  loc @ptr !State.nonce
  loc @ptr !State.counter
  loc @ptr !State.key
  loc @ptr !State.const
end

proc qr
  int int int int // (d, c, b, a)
  --
  int int int int // (d, c, b, a)
in
  memory a sizeof(word) end a !32
  memory b sizeof(word) end b !32
  memory c sizeof(word) end c !32
  memory d sizeof(word) end d !32

  a @32 b @32  +  a !32 // a += b
  d @32 a @32  ^  d !32 // d ^= a
  d @32 16    <<< d !32 // d <<<= 16

  c @32 d @32  +  c !32 // c += d
  b @32 c @32  ^  b !32 // b ^= c
  b @32 12    <<< b !32 // b <<<= 12

  a @32 b @32  +  a !32 // a += b
  d @32 a @32  ^  d !32 // d ^= a
  d @32 8     <<< d !32 // d <<<= 8

  c @32 d @32  +  c !32 // c += d
  b @32 c @32  ^  b !32 // b ^= c
  b @32 7     <<< b !32 // b <<<= 7

  d @32
  c @32
  b @32
  a @32
end

proc qr_index
  int int int int // indexes (a, b, c, d)
  ptr // State
in
  memory state sizeof(ptr) end state !ptr
  memory d sizeof(int) end d !64
  memory c sizeof(int) end c !64
  memory b sizeof(int) end b !64
  memory a sizeof(int) end a !64

  state   @ptr sizeof(word) d @64 * ptr+ @32
    state @ptr sizeof(word) c @64 * ptr+ @32
    state @ptr sizeof(word) b @64 * ptr+ @32
    state @ptr sizeof(word) a @64 * ptr+ @32

    qr

    state @ptr sizeof(word) a @64 * ptr+ !32
    state @ptr sizeof(word) b @64 * ptr+ !32
    state @ptr sizeof(word) c @64 * ptr+ !32
  state   @ptr sizeof(word) d @64 * ptr+ !32
end

proc round_odd
  ptr // State
in
  memory state sizeof(ptr) end state !ptr
  0 4  8 12 state @ptr qr_index // column 1
  1 5  9 13 state @ptr qr_index // column 2
  2 6 10 14 state @ptr qr_index // column 3
  3 7 11 15 state @ptr qr_index // column 4
end

proc round_even
  ptr // State
in
  memory state sizeof(ptr) end state !ptr
  0 5 10 15 state @ptr qr_index // diagonal 1
  1 6 11 12 state @ptr qr_index // diagonal 2
  2 7  8 13 state @ptr qr_index // diagonal 3
  3 4  9 14 state @ptr qr_index // diagonal 4
end

// TODO: if this is inlined, program segfaults (compiler bug?)
proc block_no_add
  ptr // State
  int // num_rounds
in
  1 while over over >= do
    dup 1 and 0 = if // if current round is even
      rot dup round_even
      rot rot
    else
      rot dup round_odd
      rot rot
    end
    1 +
  end drop
  drop drop
end

proc state+
  // State 1 += State 2
  ptr // State 1
  ptr // State 2
in
  memory s2 sizeof(ptr) end s2 !ptr
  memory s1 sizeof(ptr) end s1 !ptr
  0 while dup sizeof(State) < do
    s1 @ptr over ptr+ @32      // push s1[i]
    over s2 @ptr swap ptr+ @32 // push s2[i]
    +
    over s1 @ptr swap ptr+ !32 // s1[i] = s1[i] + s2[i]

    sizeof(word) +
  end drop
end

proc block
  ptr // State
  int // num_rounds
in
  // make copy of original state
  memory original sizeof(State) end
  over sizeof(State) swap original memcpy drop

  // compute rounds
  over over block_no_add

  // add original to current state
  drop original state+
end
